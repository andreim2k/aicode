#!/bin/bash

set -euo pipefail

# Global variables for proxy cleanup
PROXY_PID=""
PROXY_PORT=""
PROXY_LOG=""
PROXY_CLEANED_UP=false

# Cleanup function that handles both cursor restoration and proxy cleanup
cleanup_on_exit() {
    # Restore cursor
    printf "\033[?25h"
    
    # Cleanup proxy if it was started and not already cleaned up
    if [ "$PROXY_CLEANED_UP" = false ] && ([ -n "$PROXY_PID" ] || [ -n "$PROXY_PORT" ]); then
        cleanup_proxy "$PROXY_PORT" "$PROXY_PID" "$PROXY_LOG" 2>/dev/null || true
        PROXY_CLEANED_UP=true
    fi
    
    exit 0
}

# Set trap for cleanup on exit/interrupt
trap cleanup_on_exit INT TERM EXIT

# Check if claude is installed
if ! command -v claude &> /dev/null; then
    echo "Error: claude command is not installed. Please install it first."
    echo "Visit: https://github.com/anthropics/claude-cli"
    exit 1
fi

# Paths
CONFIG_DIR="${HOME}/.config/aicode"
SETTINGS_FILE="${CONFIG_DIR}/settings.json"
CLAUDE_CONFIG_DIR="${HOME}/.claude"
CLAUDE_CONFIG_FILE="${CLAUDE_CONFIG_DIR}/settings.json"

# Create config directory if it doesn't exist
mkdir -p "${CONFIG_DIR}"
mkdir -p "${CLAUDE_CONFIG_DIR}"

# Check if settings.json exists
if [ ! -f "${SETTINGS_FILE}" ]; then
    echo "Error: Settings file not found at ${SETTINGS_FILE}"
    echo "Please create this file with your provider configurations."
    exit 1
fi

# Function to validate JSON
validate_json() {
    if ! jq empty "$1" 2>/dev/null; then
        echo "Error: Invalid JSON in $1"
        exit 1
    fi
}

validate_json "${SETTINGS_FILE}"

# Function to fetch models from provider API
fetch_models_from_api() {
    local base_url="$1"
    local auth_token="$2"

    # Fetch models from /models endpoint with Bearer token
    local response=$(curl -s -H "Authorization: Bearer ${auth_token}" \
        "${base_url%/}/models" 2>/dev/null)

    # Try multiple response formats
    local models=$(echo "$response" | jq -r '.data[].id' 2>/dev/null)
    
    # If no .data[].id, try .data[].model_id
    if [ -z "$models" ]; then
        models=$(echo "$response" | jq -r '.data[].model_id' 2>/dev/null)
    fi
    
    # If still no models, try .model[] (for Z.AI format)
    if [ -z "$models" ]; then
        models=$(echo "$response" | jq -r '.model[]' 2>/dev/null)
    fi
    
    # If still no models, try .[].id
    if [ -z "$models" ]; then
        models=$(echo "$response" | jq -r '.[].id' 2>/dev/null)
    fi

    if [ -z "$models" ]; then
        # Return empty if fetch fails
        echo ""
    else
        echo "$models"
    fi
}

# Function to get models for a provider (from settings.json or fetch from API)
get_models_for_provider() {
    local provider="$1"
    local base_url="$2"
    local auth_token="$3"

    # Check if models are in settings.json
    local settings_models=$(jq -r ".[] | select(.provider == \"${provider}\") | .models[]?" "${SETTINGS_FILE}" 2>/dev/null)

    if [ -n "$settings_models" ]; then
        # Filter and sort: exclude models with two slashes, then sort ascending (case-insensitive)
        echo "$settings_models" | grep -v '/.*/' | sort -f
        return
    fi

    # If no models in settings, fetch from API and filter
    fetch_models_from_api "$base_url" "$auth_token" | grep -v '/.*/' | sort -f
}

# Function to add model to recent cache (keep last 5) in settings.json
cache_recent_model() {
    local provider="$1"
    local model="$2"

    # Create a temporary JSON array with the new model list
    local models_array=$(echo "$model" | jq -R . | jq -s .)

    # Update settings.json: add model to front of models array for this provider, keep max 5
    local settings_data=$(cat "${SETTINGS_FILE}")

    settings_data=$(echo "$settings_data" | jq --arg provider "$provider" --arg model "$model" \
        '(.[] | select(.provider == $provider) | .models) |= [($model)] + (. - [$model]) | .[].models |= .[0:5]' 2>/dev/null)

    if [ -n "$settings_data" ] && [ "$settings_data" != "null" ]; then
        echo "$settings_data" > "${SETTINGS_FILE}"
    fi
}

# Function to create claude config - export env vars instead of creating settings.json
# This allows Claude to use environment variables which it checks first
create_claude_config() {
    local base_url="$1"
    local auth_token="$2"
    local model="$3"
    
    # Export environment variables for Claude CLI
    export ANTHROPIC_BASE_URL="${base_url}"
    export ANTHROPIC_AUTH_TOKEN="${auth_token}"
    export ANTHROPIC_MODEL="${model}"
}

# Function to extract provider data
get_provider_data() {
    local provider_name="$1"
    jq -r ".[] | select(.provider == \"${provider_name}\") | \"\(.base_url)|\(.auth_token)|\(.model)\"" "${SETTINGS_FILE}"
}

# Display menu and get selection with interactive UI
show_menu() {
    local providers_array=()
    local options=()
    
    # Add Claude as first option
    options+=("claude")
    
    # Parse providers from settings.json
    while IFS= read -r line; do
        if [ -n "$line" ]; then
            providers_array+=("$line")
            local provider_name=$(echo "$line" | jq -r '.provider')
            options+=("$provider_name")
        fi
    done < <(jq -c '.[]' "${SETTINGS_FILE}")
    
    # Show provider selection menu
    show_provider_menu
    return
}

# Hierarchical provider/model selection menu
show_provider_menu() {
    local providers_array=()
    local menu_items=()
    local menu_types=()
    local menu_parents=()
    local selected_index=0
    local expanded_provider=""

    # Add Claude as first option
    menu_items+=("claude")
    menu_types+=("provider")
    menu_parents+=("")

    # Parse providers from settings.json
    while IFS= read -r line; do
        if [ -n "$line" ]; then
            providers_array+=("$line")
            local provider_name=$(echo "$line" | jq -r '.provider')
            menu_items+=("$provider_name")
            menu_types+=("provider")
            menu_parents+=("")
        fi
    done < <(jq -c '.[]' "${SETTINGS_FILE}")
    
    printf "[1;37mSelect AI Provider and Model:[0m\n"
    
    local last_lines=0
    
    # Draw menu
    draw_menu() {
        local i=0
        local display_index=0
        local lines_count=0
        local max_window=10
        local window_start=0

        # Calculate window start to keep selected item visible
        if [ $selected_index -ge $max_window ]; then
            window_start=$((selected_index - max_window + 1))
        fi

        for item in "${menu_items[@]}"; do
            local item_type="${menu_types[$i]}"
            local item_parent="${menu_parents[$i]}"

            # Only display items within the window
            if [ $i -ge $window_start ] && [ $lines_count -lt $max_window ]; then
                if [ $i -eq $selected_index ]; then
                    if [ "$item_parent" == "" ]; then
                        printf "\033[1;32m>\033[0m \033[1;36m%s\033[0m\n" "$item"
                    else
                        # Check if it's a recent model
                        if [ "$item_type" == "model_recent" ]; then
                            # Extract star and model name, colorize star only
                            if [[ "$item" == "â˜…"* ]]; then
                                model_name="${item#â˜… }"
                                printf "\033[1;32m>\033[0m   \033[1;32mâ˜…\033[0m \033[1;33m%s\033[0m\n" "$model_name"
                            else
                                printf "\033[1;32m>\033[0m   \033[1;33m%s\033[0m\n" "$item"
                            fi
                        else
                            printf "\033[1;32m>\033[0m   \033[1;33m%-s\033[0m\n" "$item"
                        fi
                    fi
                else
                    if [ "$item_parent" == "" ]; then
                        printf "  \033[38;5;246m%s\033[0m\n" "$item"
                    else
                        # Check if it's a recent model
                        if [ "$item_type" == "model_recent" ]; then
                            # Extract star and model name, colorize star only
                            if [[ "$item" == "â˜…"* ]]; then
                                model_name="${item#â˜… }"
                                printf "    \033[38;5;246mâ”œâ”€ \033[1;32mâ˜…\033[0m %s\033[0m\n" "$model_name"
                            else
                                printf "    \033[38;5;246mâ”œâ”€ %s\033[0m\n" "$item"
                            fi
                        else
                            printf "    \033[38;5;246mâ”œâ”€ %s\033[0m\n" "$item"
                        fi
                    fi
                fi
                ((lines_count++))
            fi
            ((i++))
        done
        last_lines=$lines_count
    }
    
    draw_menu

    # Hide cursor during menu selection
    printf "\033[?25l"

    # Read arrow keys and Enter
    while IFS= read -rsn1 key; do
        if [[ $key == $'\x1b' ]]; then
            read -rsn2 key
            if [[ $key == '[A' ]]; then
                ((selected_index--))
                if [ $selected_index -lt 0 ]; then
                    selected_index=$((${#menu_items[@]} - 1))
                fi
                printf "\033[${last_lines}A\033[J"
                draw_menu
            elif [[ $key == '[B' ]]; then
                ((selected_index++))
                if [ $selected_index -ge ${#menu_items[@]} ]; then
                    selected_index=0
                fi
                printf "\033[${last_lines}A\033[J"
                draw_menu
            fi
        elif [[ $key == '' ]]; then
            # Enter key pressed
            local selected_item="${menu_items[$selected_index]}"
            local selected_type="${menu_types[$selected_index]}"
            local selected_parent="${menu_parents[$selected_index]}"
            
            # If selecting a model (has parent)
            if [ "$selected_parent" != "" ]; then
                SELECTED_PROVIDER="$selected_parent"
                # Strip star if present (from recent models)
                SELECTED_MODEL="$selected_item"
                SELECTED_MODEL="${SELECTED_MODEL#â˜… }"  # Remove leading star and space
                selected_provider_data=$(jq -c ".[] | select(.provider == \"$SELECTED_PROVIDER\")" "${SETTINGS_FILE}")
                export selected_provider_data  # Make it accessible outside the function
                # Cache this model as recently used
                cache_recent_model "$SELECTED_PROVIDER" "$SELECTED_MODEL"
                apply_provider_config
                break
            fi
            
            # If selecting Claude
            if [ "$selected_item" == "claude" ]; then
                SELECTED_PROVIDER="claude"
                if [ -f "${CLAUDE_CONFIG_FILE}" ]; then
                    rm "${CLAUDE_CONFIG_FILE}"
                fi
                unset ANTHROPIC_BASE_URL ANTHROPIC_AUTH_TOKEN ANTHROPIC_MODEL 2>/dev/null
                echo -e "\n\033[1;32mUsing provider:\033[0m \033[1;36m${selected_item}\033[0m"
                echo -e "\033[38;5;246mInitializing Claude (this may take a moment)...\033[0m"
                break
            fi
            
            # If provider is already expanded, collapse it
            if [ "$expanded_provider" == "$selected_item" ]; then
                expanded_provider=""
                # Remove models from menu
                local new_items=()
                local new_types=()
                local new_parents=()
                for j in "${!menu_items[@]}"; do
                    if [ "${menu_parents[$j]}" != "$selected_item" ]; then
                        new_items+=("${menu_items[$j]}")
                        new_types+=("${menu_types[$j]}")
                        new_parents+=("${menu_parents[$j]}")
                    fi
                done
                menu_items=("${new_items[@]}")
                menu_types=("${new_types[@]}")
                menu_parents=("${new_parents[@]}")
                if [ $selected_index -ge ${#menu_items[@]} ]; then
                    selected_index=$((${#menu_items[@]} - 1))
                fi
            else
                # Expand provider - add models (always fetch from API)
                local provider_data=$(jq -c ".[] | select(.provider == \"$selected_item\")" "${SETTINGS_FILE}")
                local base_url=$(echo "$provider_data" | jq -r '.base_url')
                local auth_token=$(echo "$provider_data" | jq -r '.auth_token')
                if [ "$selected_item" == "zai" ]; then
                    base_url="https://api.z.ai/api/paas/v4/"
                fi
                local models=()
                local cached_models=()

                # Try to fetch all models from API, fall back to settings.json if it fails
                # NOTE: Using sort -f for case-insensitive sorting but preserving original case
                local api_models=$(fetch_models_from_api "$base_url" "$auth_token" 2>/dev/null | grep -v '/.*/' | sort -f)
                while IFS= read -r model; do
                    if [ -n "$model" ]; then
                        models+=("$model")
                    fi
                done <<< "$api_models"
                
                # If API fetch failed, fall back to settings.json models
                if [ ${#models[@]} -eq 0 ]; then
                    local settings_models=$(jq -r ".[] | select(.provider == \"${selected_item}\") | .models[]?" "${SETTINGS_FILE}" 2>/dev/null | grep -v '/.*/' | sort -f)
                    while IFS= read -r model; do
                        if [ -n "$model" ]; then
                            models+=("$model")
                        fi
                    done <<< "$settings_models"
                fi

                # Get cached/recent models for this provider from settings.json to display first
                local cached_list=$(jq -r ".[] | select(.provider == \"${selected_item}\") | .models[]?" "${SETTINGS_FILE}" 2>/dev/null)
                while IFS= read -r cached_model; do
                    if [ -n "$cached_model" ]; then
                        cached_models+=("$cached_model")
                    fi
                done <<< "$cached_list"

                if [ ${#models[@]} -gt 0 ]; then
                    expanded_provider="$selected_item"
                    local insert_pos=$((selected_index + 1))
                    local new_items=()
                    local new_types=()
                    local new_parents=()
                    for j in "${!menu_items[@]}"; do
                        new_items+=("${menu_items[$j]}")
                        new_types+=("${menu_types[$j]}")
                        new_parents+=("${menu_parents[$j]}")
                        if [ $j -eq $selected_index ]; then
                            # Add cached models first (with star indicator)
                            if [ ${#cached_models[@]} -gt 0 ]; then
                                for cached_model in "${cached_models[@]}"; do
                                                    new_items+=("â˜… $cached_model")
                                    new_types+=("model_recent")
                                    new_parents+=("$selected_item")
                                done
                            fi
                            # Add remaining models (not in cache)
                            for model in "${models[@]}"; do
                                local is_cached=false
                                if [ ${#cached_models[@]} -gt 0 ]; then
                                    for cached in "${cached_models[@]}"; do
                                        if [ "$model" == "$cached" ]; then
                                            is_cached=true
                                            break
                                        fi
                                    done
                                fi
                                if [ "$is_cached" = false ]; then
                                    new_items+=("$model")
                                    new_types+=("model")
                                    new_parents+=("$selected_item")
                                fi
                            done
                        fi
                    done
                    menu_items=("${new_items[@]}")
                    menu_types=("${new_types[@]}")
                    menu_parents=("${new_parents[@]}")
                fi
            fi
            
            printf "\033[${last_lines}A\033[J"
            draw_menu
        fi
    done

    # Show cursor after menu selection
    printf "\033[?25h"
}

# Model selection menu
show_model_menu() {
    local selected_provider_data
    local models=()
    local selected_index=0

    # Get the selected provider's data
    selected_provider_data=$(jq -c ".[] | select(.provider == \"$SELECTED_PROVIDER\")" "${SETTINGS_FILE}")
    
    if [ -z "$selected_provider_data" ] || [ "$selected_provider_data" == "null" ]; then
        printf "[1;31mError: Provider configuration not found\u001b[0m\n"
        exit 1
    fi
    
    # Extract models array (from settings or fetch dynamically)
    local base_url=$(echo "$selected_provider_data" | jq -r '.base_url')
    local auth_token=$(echo "$selected_provider_data" | jq -r '.auth_token')
    if [ "$SELECTED_PROVIDER" == "zai" ]; then
        base_url="https://api.z.ai/api/paas/v4/"
    fi

    while IFS= read -r model; do
        if [ -n "$model" ]; then
            models+=("$model")
        fi
    done < <(get_models_for_provider "$SELECTED_PROVIDER" "$base_url" "$auth_token")
    
    # If only one model, use it directly
    if [ ${#models[@]} -eq 1 ]; then
        SELECTED_MODEL="${models[0]}"
        apply_provider_config
        return
    fi
    
    printf "\n[1;37mSelect Model:[0m\n"

    # Reorganize models: recent first, then rest
    local recent_models=$(jq -r ".\"${SELECTED_PROVIDER}\"[]?" "${CACHE_FILE}" 2>/dev/null)
    local reorganized_models=()

    # Add recent models first
    while IFS= read -r cached_model; do
        if [ -n "$cached_model" ]; then
            reorganized_models+=("$cached_model")
        fi
    done <<< "$recent_models"

    # Add remaining models
    for model in "${models[@]}"; do
        local found=false
        for recent in "${reorganized_models[@]}"; do
            if [ "$model" == "$recent" ]; then
                found=true
                break
            fi
        done
        if [ "$found" = false ]; then
            reorganized_models+=("$model")
        fi
    done

    # Replace models array with reorganized version
    models=("${reorganized_models[@]}")

    # Show separator if we have recent models
    if [ -n "$recent_models" ]; then
        printf "\033[38;5;246m (recent first)\033[0m"
    fi
    
    # Draw initial menu with scrolling window
    draw_model_menu() {
        local i=0
        local lines_count=0
        local max_window=10
        local window_start=0

        # Calculate window start to keep selected item visible
        if [ $selected_index -ge $max_window ]; then
            window_start=$((selected_index - max_window + 1))
        fi

        for model in "${models[@]}"; do
            # Only display models within the window
            if [ $i -ge $window_start ] && [ $lines_count -lt $max_window ]; then
                if [ $i -eq $selected_index ]; then
                    printf "\033[1;32m>\033[0m \033[1;36m%s\033[0m\n" "$model"
                else
                    printf "  \033[38;5;246m%s\033[0m\n" "$model"
                fi
                ((lines_count++))
            fi
            ((i++))
        done
    }
    
    draw_model_menu

    # Hide cursor during menu selection
    printf "\033[?25l"

    # Read arrow keys
    while IFS= read -rsn1 key; do
        if [[ $key == $'\x1b' ]]; then
            read -rsn2 key
            if [[ $key == '[A' ]]; then
                ((selected_index--))
                if [ $selected_index -lt 0 ]; then
                    selected_index=$((${#models[@]} - 1))
                fi
            elif [[ $key == '[B' ]]; then
                ((selected_index++))
                if [ $selected_index -ge ${#models[@]} ]; then
                    selected_index=0
                fi
            fi
            printf "\033[${#models[@]}A\033[J"
            draw_model_menu
        elif [[ $key == '' ]]; then
            break
        fi
    done

    # Show cursor after menu selection
    printf "\033[?25h"

    SELECTED_MODEL="${models[$selected_index]}"
    # Cache this model as recently used
    cache_recent_model "$SELECTED_PROVIDER" "$SELECTED_MODEL"
    apply_provider_config
}

# Apply provider configuration
apply_provider_config() {
    local base_url=$(echo "$selected_provider_data" | jq -r '.base_url')
    local auth_token=$(echo "$selected_provider_data" | jq -r '.auth_token')
    
    # Validate required fields
    if [ "$base_url" == "null" ] || [ "$auth_token" == "null" ]; then
        printf "[1;31mError: Provider configuration is incomplete\u001b[0m\n"
        exit 1
    fi
    
    # Create claude config with provider settings
    create_claude_config "$base_url" "$auth_token" "$SELECTED_MODEL"
    
    printf "\n[1;32mUsing provider:[0m [1;36m%s[0m ([1;33m%s[0m)\n" "$SELECTED_PROVIDER" "$SELECTED_MODEL"
}

# Function to cleanup proxy processes
# This only cleans up THIS instance's proxy, allowing multiple instances to run simultaneously
cleanup_proxy() {
    local port="$1"
    local pid="$2"
    local log_file="$3"
    local proxy_stopped=false
    
    # Only kill the specific PID we started (don't kill other instances)
    if [ -n "$pid" ] && ps -p "$pid" > /dev/null 2>&1; then
        # Verify it's actually listening on our port before killing
        local pid_on_port=$(lsof -ti:${port} 2>/dev/null | grep -w "$pid" || true)
        if [ -n "$pid_on_port" ]; then
            kill "$pid" 2>/dev/null || true
            # Wait up to 3 seconds for graceful shutdown
            local count=0
            while ps -p "$pid" > /dev/null 2>&1 && [ $count -lt 6 ]; do
                sleep 0.5
                count=$((count + 1))
            done
            # Force kill if still running
            if ps -p "$pid" > /dev/null 2>&1; then
                kill -9 "$pid" 2>/dev/null || true
            fi
            proxy_stopped=true
        fi
    fi
    
    # Only clean up processes on our specific port that match our PID
    # This prevents interfering with other instances
    if [ -n "$port" ] && [ -n "$pid" ]; then
        local pids_on_port=$(lsof -ti:${port} 2>/dev/null || true)
        if [ -n "$pids_on_port" ]; then
            # Only kill if our PID is in the list
            if echo "$pids_on_port" | grep -w "$pid" > /dev/null 2>&1; then
                kill -9 "$pid" 2>/dev/null || true
                proxy_stopped=true
            fi
        fi
    fi
    
    # Verify proxy is actually stopped and print confirmation message
    if [ -n "$port" ]; then
        # Check if proxy process is still running
        if [ -n "$pid" ] && ps -p "$pid" > /dev/null 2>&1; then
            # Process still exists, try one more force kill
            kill -9 "$pid" 2>/dev/null || true
            sleep 0.2
        fi
        # Verify it's actually stopped (check both PID and port)
        local still_running=false
        if [ -n "$pid" ] && ps -p "$pid" > /dev/null 2>&1; then
            still_running=true
        elif [ -n "$port" ] && lsof -ti:${port} > /dev/null 2>&1; then
            # Check if our PID is still on the port
            local pids_on_port=$(lsof -ti:${port} 2>/dev/null || true)
            if [ -n "$pids_on_port" ] && [ -n "$pid" ]; then
                if echo "$pids_on_port" | grep -w "$pid" > /dev/null 2>&1; then
                    still_running=true
                fi
            fi
        fi
        
        # Print confirmation message
        if [ "$still_running" = false ]; then
            printf "\033[1;32m[OK]\033[0m Proxy stopped on port %s\n" "$port"
        fi
    fi
    
    # Remove log file if specified (instance-specific log file)
    if [ -n "$log_file" ] && [ -f "$log_file" ]; then
        rm -f "$log_file" 2>/dev/null || true
    fi
}

# Function to check if port is available
check_port_available() {
    local port="$1"
    if lsof -ti:${port} > /dev/null 2>&1; then
        return 1  # Port is in use
    fi
    return 0  # Port is available
}

# Function to find an available random port
# This ensures each instance gets a unique port, allowing multiple instances to run simultaneously
find_random_port() {
    local min_port=9000
    local max_port=65535
    local attempts=0
    local max_attempts=200  # Increased attempts for better randomness
    
    # Use process ID and timestamp to seed randomness for better distribution
    local seed=$(($$ + $(date +%s)))
    RANDOM=$seed
    
    while [ $attempts -lt $max_attempts ]; do
        # Generate random port between min_port and max_port
        # Using $$ (process ID) helps ensure different instances get different ports
        local port=$((RANDOM % (max_port - min_port + 1) + min_port))
        
        if check_port_available "$port"; then
            echo "$port"
            return 0
        fi
        
        attempts=$((attempts + 1))
        # Reseed occasionally to avoid getting stuck in a pattern
        if [ $((attempts % 10)) -eq 0 ]; then
            RANDOM=$(($$ + $(date +%s) + attempts))
        fi
    done
    
    # Fallback: try sequential ports starting from a random point
    local start_port=$((RANDOM % (max_port - min_port + 1) + min_port))
    for port in $(seq $start_port $max_port) $(seq $min_port $((start_port - 1))); do
        if check_port_available "$port"; then
            echo "$port"
            return 0
        fi
    done
    
    return 1  # No available port found
}

# Function to start proxy with proper error handling
start_proxy() {
    local provider="$1"
    local port="$2"
    local base_url="$3"
    local auth_token="$4"
    local proxy_binary="$5"
    
    # Check if proxy binary exists
    if [ ! -f "$proxy_binary" ]; then
        printf "\n\033[1;31mError: Proxy binary not found at %s\033[0m\n" "$proxy_binary"
        printf "Please run install.sh to build the proxy\n"
        return 1
    fi
    
    # Check and free port if needed
    if ! check_port_available "$port"; then
        printf "\n\033[1;33mWarning: Port %s is in use, attempting to free it...\033[0m\n" "$port"
        local pids_on_port=$(lsof -ti:${port} 2>/dev/null || true)
        if [ -n "$pids_on_port" ]; then
            echo "$pids_on_port" | xargs kill -9 2>/dev/null || true
            sleep 1
        fi
        # Verify port is now free
        if ! check_port_available "$port"; then
            printf "\033[1;31mError: Could not free port %s\033[0m\n" "$port"
            return 1
        fi
    fi
    
    # Create log file with PID to ensure uniqueness across multiple instances
    local proxy_log="${CONFIG_DIR}/${provider}-proxy-$$.log"
    
    # Start proxy with command-line flags
    if [ "$provider" == "zai" ]; then
        "$proxy_binary" \
            -port "$port" \
            -z-ai-url "$base_url" \
            -z-ai-token "$auth_token" > "$proxy_log" 2>&1 &
    elif [ "$provider" == "xai" ]; then
        "$proxy_binary" \
            -port "$port" \
            -xai-url "$base_url" \
            -xai-token "$auth_token" > "$proxy_log" 2>&1 &
    else
        printf "\033[1;31mError: Unknown provider: %s\033[0m\n" "$provider"
        return 1
    fi
    
    local proxy_pid=$!
    
    # Wait for proxy to start and verify it's running
    local count=0
    while [ $count -lt 10 ]; do
        sleep 0.5
        if ! ps -p "$proxy_pid" > /dev/null 2>&1; then
            printf "\n\033[1;31mError: %s proxy failed to start\033[0m\n" "$provider"
            if [ -f "$proxy_log" ]; then
                printf "Proxy error log:\n"
                cat "$proxy_log"
            fi
            return 1
        fi
        if check_port_available "$port"; then
            count=$((count + 1))
        else
            break  # Port is now in use, proxy started successfully
        fi
    done
    
    # Final verification
    if check_port_available "$port"; then
        printf "\n\033[1;31mError: %s proxy is not listening on port %s\033[0m\n" "$provider" "$port"
        kill "$proxy_pid" 2>/dev/null || true
        if [ -f "$proxy_log" ]; then
            printf "Proxy error log:\n"
            cat "$proxy_log"
        fi
        return 1
    fi
    
    printf "\n\033[1;32m[OK]\033[0m %s proxy started on port %s (PID: %s)\n" "$provider" "$port" "$proxy_pid"
    
    # Store proxy info in global variables for cleanup
    PROXY_PID="$proxy_pid"
    PROXY_PORT="$port"
    PROXY_LOG="$proxy_log"
    
    return 0
}

# Show menu and get selection
show_menu

# For Z.AI provider, start the proxy server
if [ "$SELECTED_PROVIDER" == "zai" ]; then
    # Extract base_url and auth_token from provider config
    proxy_base_url=$(echo "$selected_provider_data" | jq -r '.base_url')
    proxy_auth_token=$(echo "$selected_provider_data" | jq -r '.auth_token')
    # Override to use the correct Z.AI API endpoint
    proxy_base_url="https://api.z.ai/api/paas/v4"
    
    # Find an available random port
    proxy_port=$(find_random_port)
    if [ -z "$proxy_port" ] || [ "$proxy_port" == "" ]; then
        printf "\n\033[1;31mError: Could not find an available port for Z.AI proxy\033[0m\n"
        exit 1
    fi
    
    # Check if proxy binary exists
    if [ ! -f "${CONFIG_DIR}/z-ai-proxy" ]; then
        printf "\n\033[1;31mError: z-ai-proxy binary not found at ${CONFIG_DIR}/z-ai-proxy\033[0m\n"
        printf "Please run install.sh to build the proxy\n"
        exit 1
    fi
    # Start the proxy using the start_proxy function
    if ! start_proxy "zai" "$proxy_port" "$proxy_base_url" "$proxy_auth_token" "${CONFIG_DIR}/z-ai-proxy"; then
        exit 1
    fi
    
    # Override base URL to point to the local proxy
    export ANTHROPIC_BASE_URL="http://127.0.0.1:${proxy_port}"
    export ANTHROPIC_AUTH_TOKEN="$proxy_auth_token"
    export ANTHROPIC_MODEL="$SELECTED_MODEL"
fi

# For X.AI provider, start the proxy server
if [ "$SELECTED_PROVIDER" == "xai" ]; then
    # Ensure selected_provider_data is available
    if [ -z "$selected_provider_data" ]; then
        selected_provider_data=$(jq -c ".[] | select(.provider == \"xai\")" "${SETTINGS_FILE}")
    fi
    
    # Extract base_url and auth_token from provider config
    proxy_base_url=$(echo "$selected_provider_data" | jq -r '.base_url')
    proxy_auth_token=$(echo "$selected_provider_data" | jq -r '.auth_token')
    
    # Validate we got the data
    if [ "$proxy_auth_token" == "null" ] || [ -z "$proxy_auth_token" ]; then
        printf "\n\033[1;31mError: X.AI auth token not found in settings\033[0m\n"
        exit 1
    fi
    
    # Override to use the correct X.AI API endpoint
    proxy_base_url="https://api.x.ai/v1"
    
    # Check if proxy binary exists
    if [ ! -f "${CONFIG_DIR}/x-ai-proxy" ]; then
        printf "\n\033[1;31mError: x-ai-proxy binary not found at ${CONFIG_DIR}/x-ai-proxy\033[0m\n"
        printf "Please run install.sh to build the proxy\n"
        exit 1
    fi
    
    # Find an available random port
    proxy_port=$(find_random_port)
    if [ -z "$proxy_port" ] || [ "$proxy_port" == "" ]; then
        printf "\n\033[1;31mError: Could not find an available port for X.AI proxy\033[0m\n"
        exit 1
    fi
    
    # Start the proxy using the start_proxy function
    if ! start_proxy "xai" "$proxy_port" "$proxy_base_url" "$proxy_auth_token" "${CONFIG_DIR}/x-ai-proxy"; then
        exit 1
    fi
    
    # Override base URL to point to the local proxy
    export ANTHROPIC_BASE_URL="http://127.0.0.1:${proxy_port}"
    export ANTHROPIC_AUTH_TOKEN="$proxy_auth_token"
    export ANTHROPIC_MODEL="$SELECTED_MODEL"
fi

# Run claude command - start interactive session
claude
exit_code=$?

# Explicit cleanup before exit (trap will also handle it, but this ensures it happens)
if [ "$PROXY_CLEANED_UP" = false ] && ([ -n "$PROXY_PID" ] || [ -n "$PROXY_PORT" ]); then
    cleanup_proxy "$PROXY_PORT" "$PROXY_PID" "$PROXY_LOG" 2>/dev/null || true
    PROXY_CLEANED_UP=true
fi

exit $exit_code
